<html>
  <head>
    <title>JD-asm</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="apple-mobile-web-app-title" content="JD-asm">
    <meta name="viewport" id="vp" content="width=device-width" />
    <link rel="apple-touch-icon" href="https://recoskie.github.io/JDasm/icon.png">
    <meta property="og:image" content="https://repository-images.githubusercontent.com/24021024/5e678080-0cfe-11eb-9edf-294da025f0c1" />
    <link rel="canonical" href="https://recoskie.github.io/JDasm/" />
    <link rel="manifest" href="manifest.json">
    <style>
      html, body { height: 100%; width:100%; margin: 0px; }
      #r1 div, #r2 div { border-style:solid; border-color:black; border-width:2px; }
      /***********************************************************************************
      Create a menubar for application.
      ***********************************************************************************/
      .toolBtn { white-space: nowrap; padding: 8px; border: none; cursor: pointer; }
      .toolBar { position: relative; display: inline-block; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
      .toolBarI { display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1; }
      .toolBarI a { color: black; padding: 12px 16px; text-decoration: none; display: block; cursor: pointer; }
      .toolBarI a:hover {background-color: #f1f1f1}
      .toolBar:hover .toolBarI { display: block; }
      .toolBar:hover .toolBtn { box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); }
    </style>
    <script type="text/javascript" src="swingIO/UI.js"></script>
    <script type="text/javascript" src="RandomAccessFileV/FileReaderV.js"></script>
    <script type="text/javascript" id="Format"></script>
    <script type="text/javascript" id="coreType"></script>
    <script>
      /*------------------------------------------------------------
      This is a web based version of JDasm originally designed to run in Java.
      See https://github.com/Recoskie/JDasm/blob/master/app.java
      ------------------------------------------------------------*/
      
      var file = new FileReaderV(), r = null, r1 = null, r2 = null;
      var Tree = null, dModel = null, info = null;
      var offset = null, virtual = null, ds = null;
      
      //The currently loaded format reader.
      
      var Format = null;
      
      //Used for loading in processor core types.
      
      var coreType = null;
      
      //Enable binary tree and data model, and info window for file format readers.
      
      var formatLoad = false;
      
      //Use the file signature codes instead of file extension.
      
      var signature =
      [
        [ 0x4D, 0x5A ], //Microsoft binaries.
        [ 0x7F, 0x45, 0x4C, 0x46 ], //Linux/UNIX binaries.
        [ 0xCE, 0xFA, 0xED, 0xFE ], //32 Bit Mac/IOS binary.
        [ 0xCF, 0xFA, 0xED, 0xFE ], //64 Bit Mac/IOS binary.
        [ 0xCA, 0xFE, 0xBA, 0xBE ], //Mac/IOS universal binary.
        /*[ 0xCA, 0xFE, 0xBA, 0xBE ],*/ //Reserved for java class loader format plugin.
        [ 0x42, 0x4D ], //Bit map pictures.
        [ 0xFF, 0xD8 ], //JPEG start of image marker.
        [ 0x52, 0x49, 0x46, 0x46 ], //Multimedia RIFF file.
        [ 0x52, 0x46, 0x36, 0x34 ], //Multimedia RIFF/64 file.
        [ 0x50, 0x4B, 0x03, 0x04 ], //Compressed ZIP files.
        [ 0x50, 0x4B, 0x07, 0x08 ], //Compressed ZIP files (split).
        [ 0x50, 0x4B, 0x05, 0x06 ] //Compressed ZIP files (Empty).
      ];
      
      //The file to load. To begin decoding file types.
      
      var decodeAPP =
      [
        "Format/exe.js", "Format/elf.js", "Format/mac.js", "Format/mac.js", "Format/mac.js", /*"Format/java.js",*/
        "Format/bmp.js", "Format/jpeg.js", "Format/riff.js", "Format/riff.js",
        "Format/zip.js", "Format/zip.js", "Format/zip.js"
      ];
      
      //Format to load that only use file extension for file type.
      
      var extensions = [".com"];
      
      //What file to load for file extension.
      
      var decodeAppEX = ["Format/com.js"];
      
      //Initialize the application.
      
      function init()
      {
        r = document.getElementById("r"); r1 = document.getElementById("r1"); r2 = document.getElementById("r2");
      
        offset = new VHex("vhex1", file, false); virtual = new VHex("vhex2", file, true);
        ds = new dataInspector("data", file); ds.addEditor(offset); ds.addEditor(virtual);
      
        Tree = new tree("tree"); dModel = new dataDescriptor("dModel", file); dModel.setInspector(ds); info = document.getElementById("info");
      
        info.style.overflow = "auto"; info.innerHTML = "File format Information is displayed here, and machine code disassembly.";
        
        virtual.adjSize(); virtual.hide(true); re(); offset.hide(true); ds.hide(true);
      
        Format = document.getElementById("Format"); coreType = document.getElementById("coreType");
        
        //Open an example file.
        
        file.getFile("https://raw.githubusercontent.com/Recoskie/JDasm/master/JD-asm.jar", Open);
      }
      
      //Layout change based on window dimensions, or orientation.
      //Adjusting vPort on android seems to mess with orientation change event. Works well on iOS.
        
      var vertical = null, mobile = !isNaN( window.orientation ), vPort = (/(iPad|iPhone|iPod)/g.test(navigator.userAgent)) ? (document.getElementById ("vp") || false) : false;
      
      if( mobile )
      {
        window.matchMedia("(orientation: portrait)").onchange = function(){ re(); }
      }
      else
      {
        window.onresize = re;
      }
      
      var pageW = 0, pageH = 0; function re()
      {
        pageW = window.innerWidth; pageH = window.innerHeight;
          
        if( mobile )
        {
          pageW = screen.width; pageH = screen.height;
          if(window.matchMedia("(orientation: landscape)").matches && pageH > pageW )
          { var t = pageW; pageW = pageH; pageH = t; }
        }

        //Layout needs to be reinitialized when orientation changes.
      
        if( vertical != pageH < pageW ) { vertical = pageH < pageW; layoutInit = false; }
        
        //Update and validate UI.
        
        if(layoutInit) { resize(); } else { initLayout(); }
      }

      //Layout checks.

      var layoutInit = false, reCheck = 0, hCheck = 0;

      //Initialize the layout. Values set here do not change until window orientation changes.

      function initLayout()
      {
        //Reset everything.

        Tree.resetDims(); dModel.resetDims(); offset.resetDims(); virtual.resetDims(); ds.resetDims();
        info.style.maxWidth = info.style.maxHeight = info.style.minWidth = info.style.minHeight = info.style.width = info.style.height = "unset";

        //Initialize the layout for horizontal view.

        if( !vertical )
        {
          r.style="width:100%;display:flex;";
          r1.style="min-width:" + dModel.minWidth() + ";display:none;flex-direction:column;";
          r2.style="width:100%;display:flex;flex-direction:column;";
        
          info.style.minHeight = ds.height(ds.minHeight());

          Tree.height(dModel.height(virtual.width(offset.width(offset.height(virtual.height("100%"))))));
        }

        //Initialize the layout for vertical view.

        else
        {
          r.style="width:100%;display:flex;flex-direction:column;";
          r1.style="width:100%;height:100%;min-height:" + dModel.minHeight() + ";display:none;";
          r2.style="width:100%;display:flex;";

          virtual.height(offset.height("0px"));
        
          info.style.minWidth = ds.width(ds.minWidth());
        }

        hCheck = 0; reCheck = 0; if( formatLoad ){ formatLoaded(); } if(mobile){ adjRatio(); } resize(); layoutInit = true;
      }

      //Layout changes that only need occur when visibility of components change.
      //We always try to shrink the data tools row as small as possible.

      function visibilityChange()
      {
        //If there is no loaded format then r1 does not exist and this function can terminate.

        if( !formatLoad ) { if(mobile){ adjRatio(); } if( layoutInit ){ offset.validate(); virtual.validate(); dModel.validate(); } return; }

        //Initialize the layout for horizontal view. We want the remaining space used for column r1 in width.
        
        if( !vertical )
        {
          //Check if change occurred.

          if((t = (offset.visible || virtual.visible) ? offset.minWidth() : (ds.visible ? ds.minWidth() : "0")) != reCheck)
          {
            r1.style.width = "calc(100% - " + (parseInt(t)+4) + "px)"; r2.style.minWidth = r2.style.maxWidth = t; reCheck = t;
          }

          //Small adjustments to align the cells.

          var h = Tree.minDims[1] + dModel.minDims[1] + 4; if(!(offset.visible && virtual.visible && ds.visible)) { offset.minHeight(virtual.minHeight(h+"px")); Tree.minHeight(Tree.minDims[1]); dModel.minHeight(dModel.minDims[1]); }
          else { h = offset.minDims[1]; offset.minHeight(h+"px"); virtual.minHeight(h+"px"); Tree.minHeight(dModel.minHeight(h+"px")); }

          if(ds.visible && (offset.visible || virtual.visible)) { info.style.maxHeight = info.style.minHeight = ds.minDims[1] + "px"; info.style.height = "0px;"; }
          else if(!ds.visible && offset.visible && virtual.visible) { info.style.minHeight = "max("+h+"px,calc(50% - 4px))"; }
          else { info.style.maxHeight = info.style.minHeight = "unset"; info.style.height = "100%"; }
        }

        //Initialize the layout for vertical view. We want the remaining space used for row r1 in height.

        else
        {
          //Check if change occurred.

          if( (t = ds.visible ? ds.minHeight() : ((offset.visible || virtual.visible) ? offset.minHeight() : "0px")) != reCheck )
          {
            r1.style.height = "calc(100% - " + (parseInt(t)+4) + "px)"; reCheck = t;
          }

          //Small adjustments to align the cells.

          if((n = offset.visible + virtual.visible + ds.visible) == 3) { Tree.width(dModel.width(offset.width(virtual.width("0px")))); info.style.width = ds.width("100%"); Tree.minWidth(dModel.minWidth(offset.minDims[0])); }
          else if(n == 2)
          {
            n -= ds.visible; Tree.minWidth(Tree.minDims[0] * (s = offset.minDims[0] / (Tree.minDims[0] + dModel.minDims[0] + 2)) + "px"); dModel.minWidth(dModel.minDims[0] * s + "px");
            Tree.width((Tree.minDims[0] * (s = (n == 1 ? 70 : 50) / (Tree.minDims[0] + dModel.minDims[0] + 1))) + "%"); dModel.width((dModel.minDims[0] * s) + "%"); offset.width(virtual.width((n == 1 ? "70%" : "50%")));
            ds.width(info.style.width = (n == 1 ? "30%" : "50%"));
          }
          else { Tree.width(dModel.width(info.style.width="33.3333%")); offset.width(virtual.width(ds.width("100%"))); }
        }
        
        //Always validate components after changes.
        
        adjRatio(); if( layoutInit ){ offset.validate(); virtual.validate(); dModel.validate(); }
      }

      //Enabling or disabling format reader data model, and information output/disassembly.
      //This needs to be called when switching from landscape to portrait as the column is set to display none by default.

      function formatLoaded(v)
      {
        if( v != null ) { if( formatLoad == v ) { return; } formatLoad = v; } if( !vertical )
        {
          //When loaded we need to use min content space.

          if( formatLoad ) { offset.width(virtual.width("0px")); r2.style.maxWidth = reCheck + "px"; r1.style.display="flex"; visibilityChange(); }

          //Everything can be made 100% width as it does not need to share space with r1.

          else { offset.width(virtual.width(r2.style.maxWidth = "calc(100% - 4px)")); r1.style.display="none"; }
        }

        //Initialize the layout for vertical view. We want the remaining space used for row r1 in height.

        else
        {
          //When loaded we need to use min content space.

          if( formatLoad ) { offset.width(virtual.width(r2.style.maxHeight = "0px")); r2.style.maxHeight = reCheck + "px"; r1.style.display="flex"; visibilityChange(); }

          //Everything can be made 100% width as it does not need to share space with r1.

          else { r2.style.maxHeight = "unset"; virtual.height(offset.height(r2.style.height =  "calc(100% - 4px)")); r1.style.display="none"; }
        }
      }
      
      //Adjust the page size.
      
      function adjRatio()
      {
        //Adjust hex editors in vertical alignment.

        if(formatLoad && vertical) { offset.height(virtual.height( ds.visible ? ds.minDims[1] : "0px")); }

        //We need to specify the min width or height that best fits the mobile device.
        
        if(mobile)
        {
          if(vertical)
          {
            var mHeight = (document.getElementById("mBar").clientHeight + (formatLoad ? dModel.minDims[1] : 0) + Math.max((offset.visible || virtual.visible) ? offset.minDims[1] : 0, ds.visible ? ds.minDims[1] : 0) + 6);
            
            var mWidth = (offset.visible + virtual.visible) * offset.minDims[0]; if(mWidth == 0 && ds.visible) { mWidth += ds.minDims[0]; }
            
            mWidth = Math.max(mWidth, (formatLoad ? (Tree.minDims[0] + dModel.minDims[0]) : 0)) + 6;
            
            var s = (mWidth - pageW) > (mHeight - pageH); if(vPort){ vPort.content = s ? "width="+mWidth+"" : "height="+mHeight+""; } else { r.style.minWidth = (s ? mWidth : (mHeight * (pageW / pageH))) + "px"; }
          }
          else
          {
            var mHeight = Tree.minDims[1] + dModel.minDims[1] + 4; if(offset.visible && virtual.visible && ds.visible) { mHeight = offset.minDims[1]; }
            mHeight = Math.max((offset.visible ? mHeight : 0) + (virtual.visible ? mHeight : 0) + (ds.visible ? ds.minDims[1] : 0) + 4, Tree.minDims[1] + dModel.minDims[1] + 4);
            
            var mWidth = dModel.minDims[0] + ((offset.visible || virtual.visible) ? offset.minDims[0] : ds.minDims[0]);
            
            var s = (mWidth - pageW) > (mHeight - pageH); if(vPort){ vPort.content = s ? "width="+mWidth+"" : "height="+mHeight+""; } else { r.style.minWidth = (s ? mWidth : (mHeight * (pageW / pageH))) + "px"; }
          }
        }
        
        //Size of page can be min width of r1 and r2 in the layout direction of the page in a web browser window.
        
        else
        {
          if(vertical)
          {
            r.style.minWidth = Math.max((offset.visible ? offset.minDims[0] : 0) + (virtual.visible ? virtual.minDims[0] : 0) + (ds.visible ? ds.minDims[0] : 0) + 4, Tree.minDims[0] + dModel.minDims[0] + 4) + "px";
          }
          else
          {
            var h = Tree.minDims[1] + dModel.minDims[1] + 4; if(offset.visible && virtual.visible && ds.visible) { h = offset.minDims[1]; }
            r.style.minHeight = Math.max((offset.visible ? h : 0) + (virtual.visible ? h : 0) + (ds.visible ? ds.minDims[1] : 0) + 4, Tree.minDims[1] + dModel.minDims[1] + 4) + "px";
          }
        }
      }

      //As the window resizes the menu bar can change height and needs to be subtracted from total page height.
      //The hex editors and data model component also need to be checked when window width and height changes.

      function resize()
      { 
        //Check if menu bar height change occurred.
        
        if( (t = document.getElementById("mBar").clientHeight + "px") != hCheck )
        {
          r.style.height = 'calc(100% - ' + t + ')'; hCheck = t;
        }

        offset.validate(); virtual.validate(); dModel.validate();
      }
      
      //Drag and drop file Support.
      
      var dragItem = null, setItem = null; window.addEventListener("dragover",function(e){ (e = e || event).preventDefault(); }, false );
      window.addEventListener("drop",function(e)
      {
        (e = e || event).preventDefault(); if (items = e.dataTransfer.items)
        {
          for( var i = 0; i < items.length; i++ )
          {
            if (items[i].kind === "file") { Open(items[i].getAsFile()); return; }
          }
        }
      }, false );

      //Open a file from a web address.

      function webFile()
      {
        var url = prompt("Enter the address to the web page or file.", "https://");

        if (url != null || url != "") { file.getFile(url, Open); }
      }
      file.getError = function()
      {
        alert("<h1>Network error occurred</h1>This could be a CORS issue, a dropped internet connection, or the page does not exist. It is not possible for us to know.\
        <h1>CORS Error</h1>The CORS policy is a security feature that limits what can be read on the internet from web addresses.<br /><br />\
        The following <a href='https://simplelocalize.io/blog/posts/what-is-cors/#3-disable-browser-cors-checks' target='_blank'>link</a> explains what the CORS policy is.<br /><br />\
        JDasm can read and analyze files from other web addresses if the server is configured to allow it.<br /><br />\
        You can disable the CORS check if you really want to analyze a file from a web address without downloading the file.");
      }

      //Transfers the loaded file to the file input.
      
      function Open( f )
      {
        dragItem = f; file.setTarget( f ); offset.hide(false);
        
        //Initialize the file buffer.
        
        file.bufRead(this, "onload"); file.seek(0); file.read(file.buf);
      }
      
      function onload()
      {
        //The only way onload gets called is if the file is readable.
      
        document.getElementById("setFile").innerHTML = "Current file: " + dragItem.name; setItem = dragItem; //Update the file that is opened.
      
        //Always reset the virtual address space when loading a new file.
      
        file.resetV();
        
        offset.sel = offset.sele = 0;
        
        offset.adjSize(); offset.update(file);
        
        ds.hide(false);
      
        //Check format signature type.
      
        for( var i = 0, c = true; i < signature.length; i++ )
        {
          c = true; for( var b = 0; b < signature[i].length; b++ ){ if( signature[i][b] != file.data[b] ){ c = false; } }
      
          //Java class files have the same signature.
      
          if( c && (i != 4 || ((file.data[4] << 24) | (file.data[5] << 16) | (file.data[6] << 8) | file.data[7]) < 45) )
          {
            loadFormat( decodeAPP[i] ); return;
          }
        }

        //We can not properly identify the file extension if it is a domain name with no file path separators.

        var ex = file.name.indexOf("//",0)+2; if( ex == 1 || (ex > 1 && file.name.indexOf("/",ex) > 0) )
        {
          //Some file formats can only be identified by file extension as there is no unique signature at the start of the files data.
      
          ex = file.name.substring(file.name.lastIndexOf("."), file.name.length).toLowerCase();
      
          for( var i = 0; i < extensions.length; i++ ) { if( ex == extensions[i] ) { loadFormat(decodeAppEX[i]); return; } }
        }
      
        formatLoaded(false);
      }
      
      //Format loader.
      
      function loadFormat(url)
      {
        //If we already have the format loaded there is no need to reload the script.
      
        if( Format.src != url )
        {
          Format.parentElement.removeChild(Format); Format = document.createElement("script"); Format.src = url;
          Format.onerror = fmtErr; Format.onload = function(){ format.load(); formatLoaded(true); }; document.head.appendChild(Format);
        }
      
        //Else we just call the load operation over again.
      
        else { try{ format.load(); formatLoaded(true); } catch(e) { fmtErr(); } document.head.appendChild(Format); }
      }
      
      //core loader.
      
      function loadCore(url)
      {
        //If we already have the core loaded there is no need to reload the script.
      
        if( coreType.src != url )
        {
          coreType.parentElement.removeChild(coreType); coreType = document.createElement("script"); coreType.src = url;
          coreType.onerror = coreErr; document.head.appendChild(coreType);
        }
      }
      
      //Error message if there is a problem loading the format reader.
      
      function fmtErr() { formatLoaded(false); alert("Unable to load format reader for this file format!"); }
      
      //Error message if there is a problem loading the processor core type.
      
      function coreErr() { alert("Unable to load processor core type for disassembling this binary application!"); }
      
      //Hex editor show and hide.
      
      function showH(v)
      {
        var s = 0; if( v ) { virtual.hide(s=virtual.visible); } else { offset.hide(s=offset.visible); }
        
        document.getElementById(v ? "i2" : "i1").innerHTML = (s ? "Show " : "Hide ") + (v ? "Virtual" : "Offset");

        visibilityChange();
      }
      
      function showD()
      {
        ds.hide(ds.visible);
        
        document.getElementById("i3").innerHTML = (ds.visible ? "Hide " : "Show ") + "data types";

        visibilityChange();
      }
      
      //When a file fails to load.
      
      file.onerror = function()
      {
        //When the open file is the same as the loaded and set file, then user may have move, renamed, deleted the file on their disk drive.
      
        if( dragItem == setItem ) { alert("The file you are reading from your disk drive may have been deleted!"); return; }
        
        alert("Folders can not be read as files.<br /><br />Note if you are on macOS, applications are stored in folders.<br />To open the application's files right click, then hit show package contents.");

        dragItem = setItem; file.setTarget( setItem );
      }
      
      String.prototype.pxValue = function() { return(parseInt(this.replace("px",""))); }
      
      //Add the web application service worker.
      
      if(navigator.serviceWorker) { navigator.serviceWorker.register('/JDasm/sw.js', {scope: '/JDasm/'} ) }
    </script>
  </head>
  <body onload="init();">
    <div id="mBar" style="width:100%;background-color:#E0E0E0;">
      <input type="file" id="file" onchange="Open((dragItem = this.files)[0]);" hidden>
      <div class="toolBar">
        <button id="toolBar" class="toolBtn">File</button>
        <div class="toolBarI">
          <a onclick="document.getElementById('file').click();">Open file on device.</a>
          <a onclick="webFile();">Open file from web address.</a>
        </div>
      </div>
      <div style="display: inline-block;" class="toolBar">
        <button id="toolBar" class="toolBtn">View</button>
        <div class="toolBarI">
          <a onclick="if(offset.text){offset.setText(false);virtual.setText(false);this.innerHTML='Show text';}else{offset.setText(true);virtual.setText(true);this.innerHTML='Hide text';};visibilityChange();">Hide text</a>
          <a onclick="showH(false);" id="i1">Hide Offset</a>
          <a onclick="showH(true);" id="i2">Show Virtual</a>
          <a onclick="showD();" id="i3">Hide Data Types</a>
        </div>
      </div>
      <div style="display: inline-block;" id="setFile"></div>
    </div>
    <div id="r">
      <div id="r1">
        <div id="tree"></div>
        <div id="dModel"></div>
        <div id="info"></div>
      </div>
      <div id="r2">
        <div id="vhex1"></div>
        <div id="vhex2"></div>
        <div id="data"></div>
      </div>
    </div>
  </body>
</html>